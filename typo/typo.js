var Typo = function (dictionary) {
	if (dictionary) {
		this.dictionary = dictionary;
	
		this.rules = this._parseAFF(this._readFile(chrome.extension.getURL("lib/typo/dictionaries/en_US/en_US.aff")));
		this.dictionaryTable = this._parseDIC(this._readFile(chrome.extension.getURL("lib/typo/dictionaries/en_US/en_US.dic")));
		
		var len = 0;
		
		for (var i in this.dictionaryTable) {
			len++;
		}
		
		console.log(len);
	}
	
	return this;
};

Typo.prototype = {
	/**
	 * Read the contents of a file.
	 * 
	 * @param string path The path (relative) to the file.
	 * @return string The file data.
	 */
	
	_readFile : function (path) {
		var req = new XMLHttpRequest();
		req.open("GET", path, false);
		req.send(null);
		
		return req.responseText;
	},
	
	/**
	 * Parse the rules out from a .aff file.
	 *
	 * @param string data The contents of the affix file.
	 * @return object The rules from the file.
	 */
	
	_parseAFF : function (data) {
		var rules = {};
		
		var parts = data.split("\n\n");
		
		for (var i = 0, _len = parts.length; i < _len; i++) {
			var lines = parts[i].split("\n");
			var definition = lines.shift();
			var definitionParts = definition.split(/\s+/);
			
			var ruleType = definitionParts[0];
			
			if (ruleType == "PFX" || ruleType == "SFX") {
				var ruleCode = definitionParts[1];
				var combineable = definitionParts[2];
				
				var entries = [];
				
				for (var j = 0, _jlen = lines.length; j < _jlen; j++) {
					var line = lines[j];
					
					var lineParts = line.split(/\s+/);
					var charactersToRemove = lineParts[2];
					var charactersToAdd = lineParts[3];
					var regexToMatch = lineParts[4];
					
					entries.push( { "remove" : charactersToRemove, "add" : charactersToAdd, "match" : regexToMatch } );
				}
				
				rules[ruleCode] = { "type" : ruleType, "combineable" : (combineable == "Y"), "entries" : entries };
			}
		}
		
		return rules;
	},
	
	/**
	 * Creates a hashtable of all the possible words in this dictionary, based on the .dic and the .aff.
	 *
	 * @param string data The data from the dictionary file.
	 * @return object The dictionary hash.
	 */
	
	_parseDIC : function (data) {
		var lines = data.split("\n");
		
		// The first line is the number of words in the dictionary.
		lines.shift();
		
		var dictionaryTable = {};
		var self = this;
		
		lines.forEach(function (line) {
			var parts = line.split("/");
			
			var word = parts[0];
			
			dictionaryTable[word] = true;
			
			// Now for each affix rule, generate that form of the word.
			if (parts.length > 1) {
				var ruleCodes = parts[1].split("");
				
				ruleCodes.forEach(function (code) {
					if (code in self.rules) {
						var rule = self.rules[code];
						
						var newWord = self._applyRule(word, rule);
						
						if (newWord) {
							dictionaryTable[newWord] = true;
							
							if (rule.combineable) {
								ruleCodes.forEach(function (combineCode) {
									if (combineCode in self.rules) {
										var combineRule = self.rules[combineCode];
										
										if ((rule.type != combineRule.type) && combineRule.combineable) {
											var otherNewWord = self._applyRule(newWord, combineRule);
											
											if (otherNewWord) {
												dictionaryTable[otherNewWord] = true;
											}
										}
									}
								});
							}
						}
					}
				});
			}
			
			dictionaryTable[parts[0]] = true;
		});
		
		return dictionaryTable;
	},
	
	/**
	 * Applies an affix rule to a word.
	 *
	 * @param string word The base word.
	 * @param object rule The affix rule.
	 * @return string The new word generated by the rule.
	 */
	
	_applyRule : function (word, rule) {
		for (var i = 0, _len = rule.entries.length; i < _len; i++) {
			var entry = rule.entries[i];
			
			if (rule.type == "PFX") {
				var regex = new RegExp("^" + entry.match);
				
				if (word.match(regex)) {
					var newWord = word;
					
					if (entry.remove !== "0") {
						newWord = newWord.replace(entry.remove, "", "g");
					}
					
					newWord = entry.add + newWord;
					
					return newWord;
				}
			}
			else {
				var regex = new RegExp(entry.match + "$");
				
				if (word.match(regex)) {
					var newWord = word;
					
					if (entry.remove !== "0") {
						var removeRegex = new RegExp(entry.remove + "$", "g");
						
						newWord = newWord.replace(removeRegex, "");
					}
					
					newWord = newWord + entry.add;
					
					return newWord;
				}
			}
		}
		
		return false;
	},
	
	/**
	 * Checks whether a word exists in the current dictionary.
	 *
	 * @param string word The word to check.
	 * @return boolean
	 */
	
	check : function (word) {
		word = word.toLowerCase();
		
		return (word in this.dictionaryTable);
	},
	
	/**
	 * Returns a list of suggestions for a misspelled word.
	 *
	 * @todo Not yet implemented.
	 *
	 * @param string word The misspelling.
	 * @return string[] The array of suggestions.
	 */
	
	suggest : function (word) {
	}
};